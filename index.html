<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)">
<link rel="manifest" href="manifest.json">
<title>Textarea</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0b0d0f;
    --surface:#0f1316;
    --text:#e6eef3;
    --muted:#9aa6b2;
    --accent:#7dd3fc;
    --radius:12px;
    --max-width:820px;
  }

  @media (prefers-color-scheme: light){
    :root{
      --bg:#f7f9fb;
      --surface:#ffffff;
      --text:#0b1220;
      --muted:#52606d;
      --accent:#2563eb;
    }
  }
  /* explicit theme override (user toggle) */
  html[data-theme="light"]{
    --bg:#f7f9fb;
    --surface:#ffffff;
    --text:#0b1220;
    --muted:#52606d;
    --accent:#2563eb;
  }
  html[data-theme="dark"]{
    --bg:#0b0d0f;
    --surface:#0f1316;
    --text:#e6eef3;
    --muted:#9aa6b2;
    --accent:#7dd3fc;
  }

  *,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
  html{height:100%;color-scheme:dark light;background:var(--bg);font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial}
  body{min-height:100%;}

  /* Make the editable article itself the surface */
  article{
    outline:none;
    width:100%;
    min-height:100vh;
    padding:32px clamp(18px,4vw,40px);
    display:flex;
    align-items:flex-start;
    color:var(--text);
    -webkit-font-smoothing:antialiased;
    text-rendering:optimizeLegibility;
  }

  article{
    max-width:var(--max-width);
    margin-inline:auto;
    background:var(--surface);
    border-radius:var(--radius);
    padding:28px 28px 160px 28px;
    font:18px/1.6 Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    tab-size:4;
    white-space:pre-wrap;
    overflow-wrap:break-word;
    color:var(--text);
    position:relative;
  }

  /* placeholder (show when content is empty) */
  article[data-empty]::before{
    content: attr(data-placeholder);
    color:var(--muted);
    position:absolute;
    left:28px; top:28px;
    pointer-events:none;
    white-space:pre-wrap;
  }

  /* theme toggle button */
  #theme-toggle{
    position:fixed; right:16px; top:16px; z-index:9999; border:0; background:transparent; color:var(--text); font-size:18px; padding:8px; border-radius:10px; cursor:pointer;
    box-shadow:0 4px 18px rgba(2,6,23,0.45);
  }

  /* When the article has inline style applied by user, keep it readable */
  article[style] { box-shadow:0 8px 40px rgba(2,6,23,0.7); }

  /* Small screens tweak */
  @media (max-width:520px){
    article > *{padding:20px; border-radius:10px}
  }
</style>
<article contenteditable="plaintext-only" spellcheck data-placeholder="Start writing â€” your notes are saved to the URL hash." data-empty></article>
<button id="theme-toggle" aria-label="Toggle theme">ðŸŒ™</button>
<script>
  const article = document.querySelector('article')
  // placeholder handling
  function updateEmptyFlag(){
    if (!article.textContent || !article.textContent.trim()) article.setAttribute('data-empty','')
    else article.removeAttribute('data-empty')
  }
  updateEmptyFlag()
  article.addEventListener('input', updateEmptyFlag)
  article.addEventListener('blur', updateEmptyFlag)

  // theme toggle (stores preference)
  const html = document.documentElement
  const themeToggle = document.getElementById('theme-toggle')
  function applyTheme(t){ html.dataset.theme = t; localStorage.setItem('theme', t); themeToggle.textContent = t === 'light' ? 'â˜€ï¸' : 'ðŸŒ™' }
  const savedTheme = localStorage.getItem('theme')
  if (savedTheme) applyTheme(savedTheme)
  else applyTheme(window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches ? 'light' : 'dark')
  themeToggle.addEventListener('click', ()=> applyTheme(html.dataset.theme === 'light' ? 'dark' : 'light'))
  article.addEventListener('input', debounce(500, save))
  article.addEventListener('blur', save)
  addEventListener('DOMContentLoaded', load)
  addEventListener('hashchange', load)
  addEventListener('load', () => new MutationObserver(save).observe(article, {attributeFilter: ['style']}))
  addEventListener('keydown', e => {
    if ((e.metaKey || e.ctrlKey) && e.key === 's') {
      e.preventDefault()
      download()
    }
  })
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js')
  }

  async function load() {
    try {
      if (location.hash !== '') await set(location.hash)
      else {
        await set(localStorage.getItem('hash') ?? '')
        if (article.textContent) history.replaceState({}, '', await get())
        article.focus()
      }
    } catch (e) {
      article.textContent = ''
      article.removeAttribute('style')
      article.focus()
    }
    updateTitle()
  }

  async function save() {
    const hash = await get()
    if (location.hash !== hash) history.replaceState({}, '', hash)
    try { localStorage.setItem('hash', hash) } catch (e) {}
    updateTitle()
  }

  async function set(hash) {
    if (!hash) return
    const [content, style] = (await decompress(hash.slice(1))).split('\x00')
    article.textContent = content
    if (style) article.setAttribute('style', style)
  }

  async function get() {
    const style = article.getAttribute('style')
    const content = article.textContent + (style !== null ? '\x00' + style : '')
    return '#' + await compress(content)
  }

  function updateTitle() {
    const match = article.textContent.match(/^\n*#(.+)\n/)
    document.title = match?.[1] ?? 'Textarea'
  }

  async function compress(string) {
    const byteArray = new TextEncoder().encode(string)
    const stream = new CompressionStream('deflate-raw')
    const writer = stream.writable.getWriter()
    writer.write(byteArray)
    writer.close()
    const buffer = await new Response(stream.readable).arrayBuffer()
    return new Uint8Array(buffer).toBase64({alphabet: 'base64url'})
  }

  async function decompress(b64) {
    const byteArray = Uint8Array.fromBase64(b64, {alphabet: 'base64url'})
    const stream = new DecompressionStream('deflate-raw')
    const writer = stream.writable.getWriter()
    writer.write(byteArray)
    writer.close()
    const buffer = await new Response(stream.readable).arrayBuffer()
    return new TextDecoder().decode(buffer)
  }

  function debounce(ms, fn) {
    let timer
    return (...args) => {
      clearTimeout(timer)
      timer = setTimeout(() => fn(...args), ms)
    }
  }

  async function download() {
    updateTitle()
    const doc = document.documentElement.cloneNode(true)
    doc.querySelectorAll('script').forEach(s => s.remove())
    doc.querySelector('article').removeAttribute('contenteditable')
    const html = '<!DOCTYPE html>\n' + doc.outerHTML

    if ('showSaveFilePicker' in window) {
      try {
        const handle = await showSaveFilePicker({
          suggestedName: document.title + '.html',
          types: [{
            description: 'HTML file',
            accept: {'text/html': ['.html']},
          }],
        })
        const writable = await handle.createWritable()
        await writable.write(html)
        await writable.close()
        return
      } catch (e) {
        if (e.name === 'AbortError') return
      }
    }

    const blob = new Blob([html], {type: 'text/html'})
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = document.title + '.html'
    a.click()
    URL.revokeObjectURL(url)
  }
</script>
