<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)">
<link rel="manifest" href="manifest.json">
<title>Textarea</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0b0d0f;
    --surface:#0f1316;
    --text:#e6eef3;
    --muted:#9aa6b2;
    --accent:#7dd3fc;
    --radius:12px;
    --max-width:900px;
  }

  @media (prefers-color-scheme: light){
    :root{
      --bg:#f7f9fb;
      --surface:#ffffff;
      --text:#0b1220;
      --muted:#52606d;
      --accent:#2563eb;
    }
  }
  /* explicit theme override (user toggle) */
  html[data-theme="light"]{
    --bg:#f7f9fb;
    --surface:#ffffff;
    --text:#0b1220;
    --muted:#52606d;
    --accent:#2563eb;
  }
  html[data-theme="dark"]{
    --bg:#0b0d0f;
    --surface:#0f1316;
    --text:#e6eef3;
    --muted:#9aa6b2;
    --accent:#7dd3fc;
  }

  *,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
  html{height:100%;background:var(--bg);color-scheme:dark light;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial}

  /* Make the editable article itself the surface */
  article{
    outline:none;
    width:100%;
    min-height:100vh;
    padding:32px clamp(18px,4vw,40px);
    display:flex;
    align-items:flex-start;
    justify-content:center;
    color:var(--text);
  }

  article{
    max-width:var(--max-width);
    margin-inline:auto;
    background:var(--surface);
    border-radius:var(--radius);
    padding:28px 28px 160px 28px;
    box-shadow:0 6px 30px rgba(2,6,23,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
    font:18px/1.6 Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    tab-size:4;
    white-space:pre-wrap;
    overflow-wrap:break-word;
    color:var(--text);
    position:relative;
  }

  /* placeholder (show when content is empty) */
  article[data-empty]::before{
    content: attr(data-placeholder);
    color:var(--muted);
    position:absolute;
    left:28px; top:28px;
    pointer-events:none;
    white-space:pre-wrap;
  }

  /* theme toggle button */
  #theme-toggle{
    position:fixed; right:16px; top:16px; z-index:9999; border:0; background:transparent; color:var(--text); font-size:18px; padding:8px; border-radius:10px; cursor:pointer;
    box-shadow:0 4px 18px rgba(2,6,23,0.45);
  }

  /* Markdown specific */
  .md-code, .md-codeblock{font-family:"JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace; background:rgba(255,255,255,0.02); padding:2px 6px; border-radius:6px}
  .md-codeblock{display:block; padding:12px; margin:12px 0; overflow:auto}
  .md-bold{font-weight:600}
  .md-italic{font-style:italic}
  .md-strike{text-decoration:line-through}
  .md-link{color:var(--accent); text-decoration:underline}

  .md-h1,.md-h2,.md-h3,.md-h4,.md-h5,.md-h6{display:block;font-weight:700;margin:0.6em 0;color:var(--text)}
  .md-h1{font-size:1.8rem}
  .md-h2{font-size:1.4rem}
  .md-h3{font-size:1.15rem}
  .md-h4{font-size:1rem}
  .md-h5{font-size:0.95rem}
  .md-h6{font-size:0.9rem}

  @media (max-width:520px){
    article > *{padding:20px; border-radius:10px}
    .md-h1{font-size:1.5rem}
  }
</style>
<article contenteditable="plaintext-only" spellcheck data-placeholder="Start writing Markdown â€” preview will render here." data-empty></article>
<button id="theme-toggle" aria-label="Toggle theme">ðŸŒ™</button>
<script>
  const article = document.querySelector('article')
  // placeholder handling
  function updateEmptyFlag(){
    if (!article.textContent || !article.textContent.trim()) article.setAttribute('data-empty','')
    else article.removeAttribute('data-empty')
  }
  updateEmptyFlag()
  article.addEventListener('input', updateEmptyFlag)
  article.addEventListener('blur', updateEmptyFlag)

  // theme toggle (stores preference)
  const html = document.documentElement
  const themeToggle = document.getElementById('theme-toggle')
  function applyTheme(t){ html.dataset.theme = t; localStorage.setItem('theme', t); themeToggle.textContent = t === 'light' ? 'â˜€ï¸' : 'ðŸŒ™' }
  const savedTheme = localStorage.getItem('theme')
  if (savedTheme) applyTheme(savedTheme)
  else applyTheme(window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches ? 'light' : 'dark')
  themeToggle.addEventListener('click', ()=> applyTheme(html.dataset.theme === 'light' ? 'dark' : 'light'))
  article.addEventListener('input', debounce(500, save))
  article.addEventListener('blur', save)
  addEventListener('DOMContentLoaded', load)
  addEventListener('hashchange', load)
  addEventListener('load', () => new MutationObserver(save).observe(article, {attributeFilter: ['style']}))
  addEventListener('keydown', e => {
    if ((e.metaKey || e.ctrlKey) && e.key === 's') {
      e.preventDefault()
      download()
    }
  })
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js')
  }

  async function load() {
    try {
      if (location.hash !== '') await set(location.hash)
      else {
        await set(localStorage.getItem('hash') ?? '')
        if (article.textContent) history.replaceState({}, '', await get())
        article.focus()
      }
    } catch (e) {
      article.textContent = ''
      article.removeAttribute('style')
      article.focus()
    }
    updateTitle()
  }

  async function save() {
    const hash = await get()
    if (location.hash !== hash) history.replaceState({}, '', hash)
    try { localStorage.setItem('hash', hash) } catch (e) {}
    updateTitle()
  }

  async function set(hash) {
    if (!hash) return
    const [content, style] = (await decompress(hash.slice(1))).split('\x00')
    article.textContent = ''
    article.appendChild(parseMarkdown(content))
    if (style) article.setAttribute('style', style)
  }

  async function get() {
    const style = article.getAttribute('style')
    const content = article.textContent + (style !== null ? '\x00' + style : '')
    return '#' + await compress(content)
  }

  function updateTitle() {
    const match = article.textContent.match(/^\n*#(.+)\n/)
    document.title = match?.[1] ?? 'Textarea'
  }

  async function compress(string) {
    const byteArray = new TextEncoder().encode(string)
    const stream = new CompressionStream('deflate-raw')
    const writer = stream.writable.getWriter()
    writer.write(byteArray)
    writer.close()
    const buffer = await new Response(stream.readable).arrayBuffer()
    return new Uint8Array(buffer).toBase64({alphabet: 'base64url'})
  }

  async function decompress(b64) {
    const byteArray = Uint8Array.fromBase64(b64, {alphabet: 'base64url'})
    const stream = new DecompressionStream('deflate-raw')
    const writer = stream.writable.getWriter()
    writer.write(byteArray)
    writer.close()
    const buffer = await new Response(stream.readable).arrayBuffer()
    return new TextDecoder().decode(buffer)
  }

  function debounce(ms, fn) {
    let timer
    return (...args) => {
      clearTimeout(timer)
      timer = setTimeout(() => fn(...args), ms)
    }
  }

  async function download() {
    updateTitle()
    const doc = document.documentElement.cloneNode(true)
    doc.querySelectorAll('script').forEach(s => s.remove())
    doc.querySelector('article').removeAttribute('contenteditable')
    const html = '<!DOCTYPE html>\n' + doc.outerHTML

    if ('showSaveFilePicker' in window) {
      try {
        const handle = await showSaveFilePicker({
          suggestedName: document.title + '.html',
          types: [{
            description: 'HTML file',
            accept: {'text/html': ['.html']},
          }],
        })
        const writable = await handle.createWritable()
        await writable.write(html)
        await writable.close()
        return
      } catch (e) {
        if (e.name === 'AbortError') return
      }
    }

    const blob = new Blob([html], {type: 'text/html'})
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = document.title + '.html'
    a.click()
    URL.revokeObjectURL(url)
  }

  function parseMarkdown(input) {
    const frag = document.createDocumentFragment()

    const matchers = [
      {name: 'md-codeblock', re: /```[^\n]*\n[\s\S]*?\n```/y},
      {name: 'md-codeblock', re: /~~~[^\n]*\n[\s\S]*?\n~~~/y},
      {name: 'md-h1', re: /^#[ \t]+[^\n]*$/my},
      {name: 'md-h2', re: /^##[ \t]+[^\n]*$/my},
      {name: 'md-h3', re: /^###[ \t]+[^\n]*$/my},
      {name: 'md-h4', re: /^####[ \t]+[^\n]*$/my},
      {name: 'md-h5', re: /^#####[ \t]+[^\n]*$/my},
      {name: 'md-h6', re: /^######[ \t]+[^\n]*$/my},
      {name: 'md-code', re: /`[^`\n]*`/y},
      {name: 'md-bold', re: /\*\*[^*\n]+?\*\*/y},
      {name: 'md-strike', re: /~~[^~\n]+?~~/y},
      {name: 'md-italic', re: /\*[^*\n]+?\*/y},
      {name: 'md-link', re: /\[[^\]\n]+?\]\([^) \n]+?\)/y}
    ]

    const specials = ['`', '~', '*', '[', '#']

    let i = 0
    while (i < input.length) {
      let matched = false

      for (const m of matchers) {
        m.re.lastIndex = i
        const res = m.re.exec(input)
        if (res && res.index === i) {
          const raw = res[0]
          const span = document.createElement('span')
          span.className = m.name
          span.textContent = raw
          frag.appendChild(span)
          i += raw.length
          matched = true
          break
        }
      }

      if (matched) continue

      let next = input.length
      for (const ch of specials) {
        const idx = input.indexOf(ch, i)
        if (idx !== -1 && idx < next) next = idx
      }

      if (next === i) {
        frag.appendChild(document.createTextNode(input[i]))
        i += 1
        continue
      }

      frag.appendChild(document.createTextNode(input.slice(i, next)))
      i = next
    }

    return frag
  }
</script>
